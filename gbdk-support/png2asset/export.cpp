#include <vector>
#include <string>
#include <algorithm>
#include <cstring>
#include <set>
#include <stdio.h>
#include <fstream>
#include <cstdint>

#include "lodepng.h"
#include "mttile.h"

#include "cmp_int_color.h"
#include "metasprites.h"

using namespace std;

#include "png2asset.h"
#include "export.h"
#include "image_utils.h"
#include "process_arguments.h"

int HandleExport( PNG2AssetData* png2AssetData) {
	// === EXPORT ===

	// Header file export
	if(export_h_file(png2AssetData) == false) return 1; // Exit with Fail

	if((png2AssetData->arguments.export_as_map) && (png2AssetData->arguments.output_binary)) {
		// Handle special case of binary map export
		export_map_binary(png2AssetData);
	}
	else {
		// Normal source file export
		if(export_c_file(png2AssetData) == false) return 1; // Exit with Fail
	}

	return 0;
}

void Export(const PNGImage& image, const char* path,   PNG2AssetData* png2AssetData)
{
	lodepng::State state;
	state.info_png.color.colortype = LCT_PALETTE;
	state.info_png.color.bitdepth = 8;
	state.info_raw.colortype = LCT_PALETTE;
	state.info_raw.bitdepth = 8;
	state.encoder.auto_convert = 0; //we specify ourselves exactly what output PNG color mode we want

#define ADD_PALETTE(R, G, B, A) lodepng_palette_add(&state.info_png.color, R, G, B, A); lodepng_palette_add(&state.info_raw, R, G, B, A)
	for(size_t p = 0; p < image.total_color_count; ++p)
	{
		unsigned char* c = &image.palette[p * RGBA32_SZ];
		ADD_PALETTE(c[0], c[1], c[2], c[3]);
	}

	std::vector<unsigned char> buffer;
	lodepng::encode(buffer, image.data, image.w, image.h, state);
	lodepng::save_file(buffer, path);
}

bool export_h_file( PNG2AssetData* png2AssetData) {

	FILE* file;

	file = fopen(png2AssetData->arguments.output_filename_h.c_str(), "w");
	if(!file) {
		printf("Error writing file: %s", png2AssetData->arguments.output_filename_h.c_str());
		return false;
	}

	fprintf(file, "//AUTOGENERATED FILE FROM png2asset\n");
	fprintf(file, "#ifndef METASPRITE_%s_H\n", png2AssetData->arguments.data_name.c_str());
	fprintf(file, "#define METASPRITE_%s_H\n", png2AssetData->arguments.data_name.c_str());
	fprintf(file, "\n");
	fprintf(file, "#include <stdint.h>\n");
	fprintf(file, "#include <gbdk/platform.h>\n");
	fprintf(file, "#include <gbdk/metasprites.h>\n");
	fprintf(file, "\n");
	if(png2AssetData->arguments.use_structs)
	{
		if(png2AssetData->arguments.export_as_map)
		{
			fprintf(file, "#include \"TilesInfo.h\"\n");
			fprintf(file, "#include \"MapInfo.h\"\n");
			fprintf(file, "\n");
			fprintf(file, "extern const struct TilesInfo %s_tiles_info;\n", png2AssetData->arguments.data_name.c_str());
			fprintf(file, "extern const struct MapInfo %s;\n", png2AssetData->arguments.data_name.c_str());
		}
		else
		{
			fprintf(file, "#include \"MetaSpriteInfo.h\"\n");
			fprintf(file, "\n");
			fprintf(file, "extern const struct MetaSpriteInfo %s;\n", png2AssetData->arguments.data_name.c_str());
		}
	}
	else
	{
		fprintf(file, "#define %s_TILE_ORIGIN %d\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->arguments.tile_origin);
		fprintf(file, "#define %s_TILE_W %d\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->image.tile_w);
		fprintf(file, "#define %s_TILE_H %d\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->image.tile_h);
		fprintf(file, "#define %s_WIDTH %d\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->arguments.sprite_w);
		fprintf(file, "#define %s_HEIGHT %d\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->arguments.sprite_h);
		// The TILE_COUNT calc here is referring to number of 8x8 tiles,
		// so the >> 3 for each sizes axis is to get a multiplier for larger hardware sprites such as 8x16 and 16x16
		fprintf(file, "#define %s_TILE_COUNT %d\n", png2AssetData->arguments.data_name.c_str(), ((unsigned int)png2AssetData->tiles.size() - png2AssetData->arguments.source_tileset_size) * (png2AssetData->image.tile_h >> 3) * (png2AssetData->image.tile_w >> 3));
		if(png2AssetData->arguments.include_palettes) {
			fprintf(file, "#define %s_PALETTE_COUNT %d\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)(png2AssetData->image.total_color_count / png2AssetData->image.colors_per_pal));
			fprintf(file, "#define %s_COLORS_PER_PALETTE %d\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)png2AssetData->image.colors_per_pal);
			fprintf(file, "#define %s_TOTAL_COLORS %d\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)png2AssetData->image.total_color_count);
		}

		if(png2AssetData->arguments.includedMapOrMetaspriteData) {

			if(png2AssetData->arguments.export_as_map)
			{
				fprintf(file, "#define %s_MAP_ATTRIBUTES ", png2AssetData->arguments.data_name.c_str());
				if(png2AssetData->arguments.use_map_attributes && png2AssetData->map_attributes.size())
					fprintf(file, "%s_map_attributes\n", png2AssetData->arguments.data_name.c_str());
				else
					fprintf(file, "0\n");

				if(png2AssetData->arguments.use_map_attributes)
				{
					int scale = png2AssetData->arguments.use_2x2_map_attributes ? 2 : 1;
					fprintf(file, "#define %s_MAP_ATTRIBUTES_WIDTH %d\n", png2AssetData->arguments.data_name.c_str(), (int)(scale * png2AssetData->arguments.map_attributes_width));
					fprintf(file, "#define %s_MAP_ATTRIBUTES_HEIGHT %d\n", png2AssetData->arguments.data_name.c_str(), (int)(scale * png2AssetData->arguments.map_attributes_height));
					fprintf(file, "#define %s_MAP_ATTRIBUTES_PACKED_WIDTH %d\n", png2AssetData->arguments.data_name.c_str(), (int)png2AssetData->arguments.map_attributes_packed_width);
					fprintf(file, "#define %s_MAP_ATTRIBUTES_PACKED_HEIGHT %d\n", png2AssetData->arguments.data_name.c_str(), (int)png2AssetData->arguments.map_attributes_packed_height);
				}

				if(png2AssetData->arguments.use_structs)
				{
					fprintf(file, "#define %s_TILE_PALS ", png2AssetData->arguments.data_name.c_str());
					if(png2AssetData->arguments.use_map_attributes)
						fprintf(file, "0\n");
					else
						fprintf(file, "%s_tile_pals\n", png2AssetData->arguments.data_name.c_str());
				}
			}
			else
			{
				fprintf(file, "#define %s_PIVOT_X %d\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->arguments.pivot_x);
				fprintf(file, "#define %s_PIVOT_Y %d\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->arguments.pivot_y);
				fprintf(file, "#define %s_PIVOT_W %d\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->arguments.pivot_w);
				fprintf(file, "#define %s_PIVOT_H %d\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->arguments.pivot_h);
			}
		}
		fprintf(file, "\n");
		fprintf(file, "BANKREF_EXTERN(%s)\n", png2AssetData->arguments.data_name.c_str());
		fprintf(file, "\n");

		// If we are not using a source tileset, or if we have extra palettes defined
		if(png2AssetData->arguments.include_palettes && (png2AssetData->image.total_color_count - png2AssetData->arguments.source_total_color_count > 0 || !png2AssetData->arguments.use_source_tileset)) {
			fprintf(file, "extern const palette_color_t %s_palettes[%d];\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)png2AssetData->image.total_color_count - png2AssetData->arguments.source_total_color_count);
		}
		if(png2AssetData->arguments.includeTileData) {
			fprintf(file, "extern const uint8_t %s_tiles[%d];\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)((png2AssetData->tiles.size() - png2AssetData->arguments.source_tileset_size) * (png2AssetData->image.tile_w * png2AssetData->image.tile_h * png2AssetData->arguments.bpp / 8)));
		}

		fprintf(file, "\n");
		if(png2AssetData->arguments.includedMapOrMetaspriteData) {
			if(png2AssetData->arguments.export_as_map)
			{
				fprintf(file, "extern const unsigned char %s_map[%d];\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)(png2AssetData->map).size());

				if(png2AssetData->arguments.use_map_attributes && png2AssetData->map_attributes.size()) {
					fprintf(file, "extern const unsigned char %s_map_attributes[%d];\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)(png2AssetData->map_attributes).size());
				}
				else
				{
					// Some platforms (like SMS/GG) encode attributes as part of map
					// For compatibility, add a define that makes _map_attributes equal _map,
					// so that set_bkg_attributes can work the same on these platforms
					fprintf(file, "#define %s_map_attributes %s_map\n", png2AssetData->arguments.data_name.c_str(), png2AssetData->arguments.data_name.c_str());
				}
				if(!png2AssetData->arguments.use_map_attributes && (png2AssetData->arguments.includeTileData) && (png2AssetData->arguments.use_structs)) {
					fprintf(file, "extern const unsigned char* %s_tile_pals[%d];\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)(png2AssetData->tiles).size());
				}
			}
			else
			{
				fprintf(file, "extern const metasprite_t* const %s_metasprites[%d];\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)(png2AssetData->sprites.size()));
			}
		}
	}
	fprintf(file, "\n");
	fprintf(file, "#endif\n");


	fclose(file);
	// END: Output .h FILE

	return true; // success
}



bool export_c_file( PNG2AssetData* png2AssetData) {

	FILE* file;

	file = fopen(png2AssetData->arguments.output_filename.c_str(), "w");
	if(!file) {
		printf("Error writing file: %s", png2AssetData->arguments.output_filename.c_str());
		return false;
	}

	if(png2AssetData->arguments.bank >= 0) fprintf(file, "#pragma bank %d\n\n", png2AssetData->arguments.bank);

	fprintf(file, "//AUTOGENERATED FILE FROM png2asset\n\n");

	fprintf(file, "#include <stdint.h>\n");
	fprintf(file, "#include <gbdk/platform.h>\n");
	fprintf(file, "#include <gbdk/metasprites.h>\n");
	fprintf(file, "\n");

	fprintf(file, "BANKREF(%s)\n\n", png2AssetData->arguments.data_name.c_str());

	// Are we not using a source tileset, or do we have extra colors
	if(png2AssetData->arguments.include_palettes && (png2AssetData->image.total_color_count - png2AssetData->arguments.source_total_color_count > 0 || !png2AssetData->arguments.use_source_tileset)) {

		// Subtract however many palettes we had in the source tileset
		fprintf(file, "const palette_color_t %s_palettes[%d] = {\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)png2AssetData->image.total_color_count - png2AssetData->arguments.source_total_color_count);

		// Offset by however many palettes we had in the source tileset
		for(size_t i = png2AssetData->arguments.source_total_color_count / png2AssetData->image.colors_per_pal; i < png2AssetData->image.total_color_count / png2AssetData->image.colors_per_pal; ++i)
		{
			if(i != 0)
				fprintf(file, ",\n");
			fprintf(file, "\t");

			unsigned char* pal_ptr = &png2AssetData->image.palette[i * (png2AssetData->image.colors_per_pal * RGBA32_SZ)];
			for(int c = 0; c < (int)png2AssetData->image.colors_per_pal; ++c, pal_ptr += RGBA32_SZ)
			{
				size_t rgb222 = (((pal_ptr[2] >> 6) & 0x3) << 4) |
					(((pal_ptr[1] >> 6) & 0x3) << 2) |
					(((pal_ptr[0] >> 6) & 0x3) << 0);
				if(png2AssetData->arguments.convert_rgb_to_nes)
					fprintf(file, "0x%0X", png2AssetData->rgb_to_nes[rgb222]);
				else
					fprintf(file, "RGB8(%3d,%3d,%3d)", pal_ptr[0], pal_ptr[1], pal_ptr[2]);
				if(c != (int)png2AssetData->image.colors_per_pal - 1)
					fprintf(file, ", ");
				// Line break every 4 color entries, to keep line width down
				if(((c + 1) % 4) == 0)
					fprintf(file, "\n\t");
			}
		}
		fprintf(file, "\n};\n");
	}

	if(png2AssetData->arguments.includeTileData) {
		fprintf(file, "\n");
		fprintf(file, "const uint8_t %s_tiles[%d] = {\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)((png2AssetData->tiles.size() - png2AssetData->arguments.source_tileset_size) * png2AssetData->image.tile_w * png2AssetData->image.tile_h * png2AssetData->arguments.bpp / 8));
		fprintf(file, "\t");
		for(vector< Tile >::iterator it = png2AssetData->tiles.begin() + png2AssetData->arguments.source_tileset_size; it != png2AssetData->tiles.end(); ++it)
		{

			int line_break = 1; // Start with 1 to prevent line break on first iteration
			vector< unsigned char > packed_data = (*it).GetPackedData(png2AssetData->arguments.pack_mode, png2AssetData->image.tile_w, png2AssetData->image.tile_h, png2AssetData->arguments.bpp);
			for(vector< unsigned char >::iterator it2 = packed_data.begin(); it2 != packed_data.end(); ++it2)
			{
				fprintf(file, "0x%02x", (*it2));
				if((it + 1) != png2AssetData->tiles.end() || (it2 + 1) != packed_data.end())
					fprintf(file, ",");
				// Add a line break after each 8x8 tile
				if(((line_break++) % (8 / png2AssetData->arguments.bpp)) == 0)
					fprintf(file, "\n\t");
			}

			if((!png2AssetData->arguments.export_as_map) && (it != png2AssetData->tiles.end()))
				fprintf(file, "\n");
		}
		fprintf(file, "};\n\n");
	}

	if(png2AssetData->arguments.includedMapOrMetaspriteData) {

		if(!png2AssetData->arguments.export_as_map)
		{
			for(vector< MetaSprite >::iterator it = png2AssetData->sprites.begin(); it != png2AssetData->sprites.end(); ++it)
			{
				fprintf(file, "const metasprite_t %s_metasprite%d[] = {\n", png2AssetData->arguments.data_name.c_str(), (int)(it - png2AssetData->sprites.begin()));
				for(MetaSprite::iterator it2 = (*it).begin(); it2 != (*it).end(); ++it2)
				{
					int pal_idx = (*it2).props & 0xF;
					int flip_x = ((*it2).props >> 5) & 1;
					int flip_y = ((*it2).props >> 6) & 1;
					fprintf(file,
						"\tMETASPR_ITEM(%d, %d, %d, S_PAL(%d)%s%s),\n",
						(*it2).offset_y,
						(*it2).offset_x,
						(*it2).offset_idx,
						pal_idx,
						flip_x ? " | S_FLIPX" : "",
						flip_y ? " | S_FLIPY" : "");
				}
				fprintf(file, "\tMETASPR_TERM\n");
				fprintf(file, "};\n\n");
			}

			fprintf(file, "const metasprite_t* const %s_metasprites[%d] = {\n\t", png2AssetData->arguments.data_name.c_str(), (unsigned int)(png2AssetData->sprites.size()));
			for(vector< MetaSprite >::iterator it = png2AssetData->sprites.begin(); it != png2AssetData->sprites.end(); ++it)
			{
				fprintf(file, "%s_metasprite%d", png2AssetData->arguments.data_name.c_str(), (int)(it - png2AssetData->sprites.begin()));
				if(it + 1 != png2AssetData->sprites.end())
					fprintf(file, ", ");
			}
			fprintf(file, "\n};\n");

			if(png2AssetData->arguments.use_structs)
			{
				fprintf(file, "\n");
				fprintf(file, "#include \"MetaSpriteInfo.h\"\n");
				fprintf(file, "const struct MetaSpriteInfo %s = {\n", png2AssetData->arguments.data_name.c_str());
				fprintf(file, "\t%d, //width\n", png2AssetData->arguments.pivot_w);
				fprintf(file, "\t%d, //height\n", png2AssetData->arguments.pivot_h);
				fprintf(file, "\t%d, //num tiles\n", (unsigned int)png2AssetData->tiles.size() * (png2AssetData->image.tile_h >> 3));
				fprintf(file, "\t%s_tiles, //tiles\n", png2AssetData->arguments.data_name.c_str());
				fprintf(file, "\t%d, //num palettes\n", (unsigned int)(png2AssetData->image.total_color_count / png2AssetData->image.colors_per_pal));
				fprintf(file, "\t%s_palettes, //CGB palette\n", png2AssetData->arguments.data_name.c_str());
				fprintf(file, "\t%d, //num sprites\n", (unsigned int)png2AssetData->sprites.size());
				fprintf(file, "\t%s_metasprites, //metasprites\n", png2AssetData->arguments.data_name.c_str());
				fprintf(file, "};\n");
			}
		}
		else
		{
			if(png2AssetData->arguments.includeTileData) {
				if(png2AssetData->arguments.use_structs)
				{
					//Export tiles pals (if any)
					if(!png2AssetData->arguments.use_map_attributes)
					{
						fprintf(file, "\n");
						fprintf(file, "const uint8_t %s_tile_pals[%d] = {\n\t", png2AssetData->arguments.data_name.c_str(), (unsigned int)(png2AssetData->tiles.size()) - png2AssetData->arguments.source_tileset_size);
						for(vector< Tile >::iterator it = png2AssetData->tiles.begin() + png2AssetData->arguments.source_tileset_size; it != png2AssetData->tiles.end(); ++it)
						{
							if(it != png2AssetData->tiles.begin())
								fprintf(file, ", ");
							fprintf(file, "%d", it->pal);
						}
						fprintf(file, "\n};\n");
					}
					//Export Tiles Info
					fprintf(file, "\n");
					fprintf(file, "#include \"TilesInfo.h\"\n");
					fprintf(file, "BANKREF(%s_tiles_info)\n", png2AssetData->arguments.data_name.c_str());
					fprintf(file, "const struct TilesInfo %s_tiles_info = {\n", png2AssetData->arguments.data_name.c_str());
					fprintf(file, "\t%d, //num tiles\n", (unsigned int)png2AssetData->tiles.size() * (png2AssetData->image.tile_h >> 3));
					fprintf(file, "\t%s_tiles, //tiles\n", png2AssetData->arguments.data_name.c_str());
					fprintf(file, "\t%d, //num palettes\n", (unsigned int)(png2AssetData->image.total_color_count / png2AssetData->image.colors_per_pal));
					fprintf(file, "\t%s_palettes, //palettes\n", png2AssetData->arguments.data_name.c_str());
					if(!png2AssetData->arguments.use_map_attributes)
						fprintf(file, "\t%s_tile_pals, //tile palettes\n", png2AssetData->arguments.data_name.c_str());
					else
						fprintf(file, "\t0 //tile palettes\n");
					fprintf(file, "};\n");
				}
			}

			//Export map
			fprintf(file, "\n");
			fprintf(file, "const unsigned char %s_map[%d] = {\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)(png2AssetData->map.size()));
			size_t line_size = png2AssetData->map.size() / (png2AssetData->image.h / 8);
			if(png2AssetData->arguments.output_transposed) {

				for(size_t i = 0; i < line_size; ++i)
				{
					fprintf(file, "\t");
					for(size_t j = 0; j < png2AssetData->image.h / 8; ++j)
					{
						fprintf(file, "0x%02x,", png2AssetData->map[j * line_size + i]);
					}
					fprintf(file, "\n");
				}
			}
			else {

				for(size_t j = 0; j < png2AssetData->image.h / 8; ++j)
				{
					fprintf(file, "\t");
					for(size_t i = 0; i < line_size; ++i)
					{
						fprintf(file, "0x%02x,", png2AssetData->map[j * line_size + i]);
					}
					fprintf(file, "\n");
				}
			}
			fprintf(file, "};\n");


			//Export map attributes (if any)
			if(png2AssetData->arguments.use_map_attributes && png2AssetData->map_attributes.size())
			{
				fprintf(file, "\n");
				fprintf(file, "const unsigned char %s_map_attributes[%d] = {\n", png2AssetData->arguments.data_name.c_str(), (unsigned int)(png2AssetData->map_attributes.size()));
				if(png2AssetData->arguments.output_transposed) {
					for(size_t i = 0; i < png2AssetData->arguments.map_attributes_packed_width; ++i)
					{
						fprintf(file, "\t");
						for(size_t j = 0; j < png2AssetData->arguments.map_attributes_packed_height; ++j)
						{
							fprintf(file, "0x%02x,", png2AssetData->map_attributes[j * png2AssetData->arguments.map_attributes_packed_width + i]);
						}
						fprintf(file, "\n");
					}
				}
				else {
					for(size_t j = 0; j < png2AssetData->arguments.map_attributes_packed_height; ++j)
					{
						fprintf(file, "\t");
						for(size_t i = 0; i < png2AssetData->arguments.map_attributes_packed_width; ++i)
						{
							fprintf(file, "0x%02x,", png2AssetData->map_attributes[j * png2AssetData->arguments.map_attributes_packed_width + i]);
						}
						fprintf(file, "\n");
					}
				}

				fprintf(file, "};\n");
			}

			if(png2AssetData->arguments.use_structs)
			{
				//Export Map Info
				fprintf(file, "\n");
				fprintf(file, "#include \"MapInfo.h\"\n");
				fprintf(file, "BANKREF_EXTERN(%s_tiles_info)\n", png2AssetData->arguments.data_name.c_str());
				fprintf(file, "const struct MapInfo %s = {\n", png2AssetData->arguments.data_name.c_str());
				fprintf(file, "\t%s_map, //map\n", png2AssetData->arguments.data_name.c_str());
				fprintf(file, "\t%d, //with\n", png2AssetData->image.w >> 3);
				fprintf(file, "\t%d, //height\n", png2AssetData->image.h >> 3);
				if(png2AssetData->arguments.use_map_attributes && png2AssetData->map_attributes.size())
					fprintf(file, "\t%s_map_attributes, //map attributes\n", png2AssetData->arguments.data_name.c_str());
				else
					fprintf(file, "\t%s, //map attributes\n", "0");
				fprintf(file, "\tBANK(%s_tiles_info), //tiles bank\n", png2AssetData->arguments.data_name.c_str());
				fprintf(file, "\t&%s_tiles_info, //tiles info\n", png2AssetData->arguments.data_name.c_str());
				fprintf(file, "};\n");
			}
		}
	}

	fclose(file);

	return true; // success
}


bool export_map_binary( PNG2AssetData* png2AssetData) {

	std::ofstream mapBinaryFile, mapAttributesBinaryfile, tilesBinaryFile;
	mapBinaryFile.open(png2AssetData->arguments.output_filename_bin, std::ios_base::binary);
	tilesBinaryFile.open(png2AssetData->arguments.output_filename_tiles_bin, std::ios_base::binary);

	for(vector< Tile >::iterator it = png2AssetData->tiles.begin() + png2AssetData->arguments.source_tileset_size; it != png2AssetData->tiles.end(); ++it)
	{

		vector< unsigned char > packed_data = (*it).GetPackedData(png2AssetData->arguments.pack_mode, png2AssetData->image.tile_w, png2AssetData->image.tile_h, png2AssetData->arguments.bpp);
		for(vector< unsigned char >::iterator it2 = packed_data.begin(); it2 != packed_data.end(); ++it2)
		{

			const char chars[] = { (const char)(*it2) };
			tilesBinaryFile.write(chars, 1);
		}

	}


	// Open our file for writing attributes if specified
	if(png2AssetData->arguments.use_map_attributes)mapAttributesBinaryfile.open(png2AssetData->arguments.output_filename_attributes_bin, std::ios_base::binary);

	int columns = png2AssetData->image.w >> 3;
	int rows = png2AssetData->image.h >> 3;

	// If we want the values to be column-by-column
	if(png2AssetData->arguments.output_transposed) {

		// Swap the column/row for loops
		for(int column = 0; column < columns; column++) {
			for(int row = 0; row < rows; ++row) {

				int tile = column + row * columns;

				const char mapChars[] = { (const char)png2AssetData->map[tile] };

				// Write map items column-by-column
				mapBinaryFile.write(mapChars, 1);
				if(png2AssetData->arguments.use_map_attributes) {
					const char mapAttributeChars[] = { (const char)png2AssetData->map_attributes[tile] };
					mapAttributesBinaryfile.write(mapAttributeChars, 1);
				}
			}
		}
	}
	else {

		// Write the arrays as-is, row-by-row
		mapBinaryFile.write((const char*)(&png2AssetData->map[0]), rows * columns);
		if(png2AssetData->arguments.use_map_attributes)mapAttributesBinaryfile.write((const char*)(&png2AssetData->map_attributes[0]), rows * columns);
	}

	// Finalize the files
	mapBinaryFile.close();
	tilesBinaryFile.close();
	if(png2AssetData->arguments.use_map_attributes)mapAttributesBinaryfile.close();

	return true; // success
}
